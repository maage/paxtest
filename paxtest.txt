so, for testing PaX: this is a complex problem because PaX claims
and offers a lots of things, and the 'problem space' is big. to
give you an idea of what the ultimate regression tests should
accomplish, i'll tell you the different 'dimensions' of the claims
and features and how they should be verified.


OS: i'd like to be able to run the tests on different OSs (even
    those without direct PaX support, for comparison).

    - Linux 2.2
    - Linux 2.4
    - Linux 2.5+
    - OpenBSD 3.3
    - FreeBSD 4.8
    - FreeBSD 5.0+
    - Solaris 2.9 (sparc)
    - etc


arch: PaX offers different support on different architectures, so
      some features have to be detected/tested on a per arch basis.

    - alpha
    - i386
    - parisc
    - ppc
    - sparc
    - sparc64
    - maybe ia64 and x86-64 in the future


kernel config: some of the PaX features can be enabled/disabled during
               kernel configuration itself, obviously this would change
               behaviour and should be tested. there're also non-PaX
               config options that may affect PaX (at least when there's
               a bug in PaX which is what regression testing should catch),
               so they have to be tested as well.

    - NOEXEC
    - PAGEEXEC
    - SEGMEXEC
    - MPROTECT
    - EMUTRAMP
    - EMUSIGRT
    - NOELFRELOCS
    - ETEXECRELOCS
    - EMUPLT
    - KERNEXEC
    - ASLR
    - RANDKSTACK
    - RANDUSTACK
    - RANDMMAP
    - RANDEXEC
    - CONFIG_SMP
    - CONFIG_MODULES
    - CONFIG_HIGHMEM64G

PaX flags: some of the PaX features can be enabled/disabled on a per
           executable basis, this again changes the behaviour and should
           be verified.

    - PAGEEXEC
    - SEGMEXEC
    - MPROTECT
    - RANDMMAP
    - RANDEXEC
    - EMUTRAMP


PaX features: these are the claims that should hold (or not) depending
              on all the above. note that when i speak of a section, i
              really mean the ELF segment that holds this section.

    - .data section of the main executable is not executable
    - .bss section of the main executable is not executable
    - brk() managed heap after the main executable is not executable
    - .data section of libraries is not executable
    - .bss section of libraries is not executable
    - anonymous file mappings are not executable
    - stack is not executable

    - .text section of ET_DYN ELF file mappings can be made writable once
    - .text section of the main executable can be made writable once
    - .text section of any ELF file mapping cannot made writable

    - .data section of the main executable cannot be made executable
    - .bss section of the main executable cannot be made executable
    - brk() managed heap after the main executable cannot be made executable
    - .data section of libraries cannot be made executable
    - .bss section of libraries cannot be made executable
    - anonymous file mappings cannot be made executable
    - stack cannot be made executable

    - gcc trampolines are (properly) emulated
    - signal handler return trampolines are (properly) emulated
    - valid signal handler return trampolines are automatically emulated
    - .plt entries are (properly) emulated

    - .text section of the kernel is read-only
    - nothing but the .text section of the kernel is executable
    - .rodata section of the kernel is read-only

    - mmap(PROT_EXEC|PROT_WRITE) creates a rw- mapping (silent removal of x)
    - mmap(~MAP_FIXED) returns a randomized address for file mappings
    - mmap(~MAP_FIXED) returns a randomized address for anonymous mappings
      if a 0 hint was specified
    - stack is at a randomized address
    - main executable is at a randomized address (for both ET_EXEC and ET_DYN
      ELF files)
    - task's kernel stack pointer is at a randomized address, and it changes
      on every system call

as you can see, there's a huge number of data points that should be
tested. of course not everything is equally important, but nevertheless
i'd need a regression test system that can eventually be (easily)
extended to handle all the above (and maybe more that i missed now ;-).
if you have ideas/questions/etc or even want to code something, let me
know, i'm of course open to help.

